import akshare as ak
import pandas as pd
from datetime import datetime, timedelta
import time
import os
from concurrent.futures import ThreadPoolExecutor, as_completed
import warnings
from typing import Callable, Dict, Any, List
import pandas_ta as ta
import numpy as np
import xlsxwriter
from tqdm import tqdm  # <--- 用于进度条
import math  # <--- 用于计算批次大小

# 忽略 pandas 的 SettingWithCopyWarning
warnings.filterwarnings('ignore', category=pd.errors.SettingWithCopyWarning)


# ==============================================================================
# 核心工具函数和配置
# ==============================================================================
class Config:
    """程序配置类"""

    def __init__(self):
        self.HOME_DIRECTORY = os.path.expanduser('~')
        self.SAVE_DIRECTORY = os.path.join(self.HOME_DIRECTORY, 'Downloads', 'CoreNews_Reports')
        self.TEMP_DATA_DIRECTORY = os.path.join(self.SAVE_DIRECTORY, 'ShareData')
        self.DATA_FETCH_RETRIES = 3
        self.DATA_FETCH_DELAY = 5 #
        self.MAX_WORKERS = 15  # 15个并行工作进程/进度条
        self.CODE_ALIASES = {'代码': '股票代码', '证券代码': '股票代码', '股票代码': '股票代码'}
        self.NAME_ALIASES = {'名称': '股票简称', '股票名称': '股票简称', '股票简称': '股票简称', '简称': '股票简称',
                             '简': '股票简称', '证券名称': '股票简称'}
        self.PRICE_ALIASES = {'最新价': '最新价', '现价': '最新价', '当前价格': '最新价', '今收盘': '最新价',
                              '收盘': '最新价', '收盘价': '最新价'}


def format_stock_code(code: str) -> str:
    """根据股票代码的开头数字，添加市场前缀。"""
    code_str = str(code).zfill(6)
    if code_str.startswith('6'):
        return 'sh' + code_str
    elif code_str.startswith(('0', '3')):
        return 'sz' + code_str
    elif code_str.startswith(('4', '8')):
        return 'bj' + code_str
    return code_str


# ==============================================================================
# 核心分析类 (集成 Fetching, Processing, Reporting)
# ==============================================================================
class StockAnalyzer:
    """
    股票数据获取、处理、分析和报告生成的核心类。
    """

    def __init__(self):
        self.config = Config()
        self.today_str = datetime.now().strftime("%Y%m%d")
        self.temp_dir = self.config.TEMP_DATA_DIRECTORY
        os.makedirs(self.temp_dir, exist_ok=True)
        self.executor = ThreadPoolExecutor(max_workers=self.config.MAX_WORKERS)
        self.start_time = time.time()

    def _get_file_path(self, base_name: str, cleaned: bool = False) -> str:
        """生成临时数据文件的完整路径。"""
        suffix = "_经清洗" if cleaned else ""
        file_name = f"{base_name}{suffix}_{self.today_str}.txt"
        return os.path.join(self.temp_dir, file_name)

    def _load_data_from_cache(self, file_path: str) -> pd.DataFrame:
        """从缓存加载数据。"""
        if os.path.exists(file_path):
            try:
                # 使用 '|' 分隔符，并确保股票代码是字符串格式
                df = pd.read_csv(file_path, sep='|', encoding='utf-8', dtype={'股票代码': str})
                print(f"  - 发现缓存，加载: {os.path.basename(file_path)}")
                return df
            except Exception as e:
                print(f"[WARN] 加载缓存 {os.path.basename(file_path)} 失败: {e}，将重新获取。")
        return pd.DataFrame()

    def _save_data_to_cache(self, df: pd.DataFrame, file_path: str):
        """保存数据到缓存。"""
        try:
            df.to_csv(file_path, sep='|', index=False, encoding='utf-8')
        except Exception as e:
            print(f"[ERROR] 保存数据到缓存 {os.path.basename(file_path)} 失败: {e}")

    def _safe_ak_fetch(self, fetch_func: Callable, file_base_name: str, **kwargs: Any) -> pd.DataFrame:
        """带重试、缓存和清洗的数据获取封装。"""

        # 1. 尝试从【清洗后的缓存】加载数据
        cleaned_file_path = self._get_file_path(file_base_name, cleaned=True)
        cached_df = self._load_data_from_cache(cleaned_file_path)
        if not cached_df.empty:
            return cached_df

        # 2. 如果清洗后的缓存不存在，则尝试从原始获取
        df = pd.DataFrame()
        for i in range(self.config.DATA_FETCH_RETRIES):
            try:
                print(f"  - 正在尝试第 {i + 1}/{self.config.DATA_FETCH_RETRIES} 次获取数据: {file_base_name}...")
                df = fetch_func(**kwargs)
                if df is not None and not df.empty:
                    break
                else:
                    print(f"[WARN] 数据返回为空或无效: {file_base_name}，重试中。")
                    time.sleep(self.config.DATA_FETCH_DELAY)
            except Exception as e:
                print(f"[ERROR] 获取 {file_base_name} 时出错: {e}，将在 {self.config.DATA_FETCH_DELAY} 秒后重试。")
                time.sleep(self.config.DATA_FETCH_DELAY)

        if df.empty:
            print(f"[FATAL] 所有重试均失败，返回空 DataFrame: {file_base_name}")
            return pd.DataFrame()

        # 3. 清洗数据并保存到带有 "_经清洗" 后缀的缓存文件
        cleaned_df = self._clean_and_standardize(df, file_base_name)
        if not cleaned_df.empty:
            self._save_data_to_cache(cleaned_df, cleaned_file_path)

        return cleaned_df

    def _clean_and_standardize(self, df: pd.DataFrame, df_name: str) -> pd.DataFrame:
        """通用数据清洗和列名标准化。"""
        if df.empty: return df

        # 1. 标准化列名：使用 Config 中的别名映射
        for old, new in self.config.CODE_ALIASES.items():
            if old in df.columns: df.rename(columns={old: new}, inplace=True)
        for old, new in self.config.NAME_ALIASES.items():
            if old in df.columns: df.rename(columns={old: new}, inplace=True)
        for old, new in self.config.PRICE_ALIASES.items():
            if old in df.columns: df.rename(columns={old: new}, inplace=True)

        if '股票代码' not in df.columns:
            return pd.DataFrame()

        # 2. 清洗数据
        df.dropna(subset=['股票代码'], inplace=True)
        df.drop_duplicates(subset=['股票代码'], inplace=True)
        df['股票代码'] = df['股票代码'].astype(str).str.zfill(6)

        if '最新价' in df.columns:
            df['最新价'] = pd.to_numeric(df['最新价'], errors='coerce')

        # 3. 过滤ST股 (依赖 '股票简称' 列)
        if '股票简称' in df.columns:
            cleaned_df = df[~df['股票简称'].str.contains('ST|st|退市|bj|BJ', case=False, na=False)].copy()
        else:
             cleaned_df = df.copy()

        if len(cleaned_df) == 0:
            print(f"[WARN] {df_name} 数据清洗后为空。")
            return pd.DataFrame()

        return cleaned_df

    def _get_all_raw_data(self) -> Dict[str, pd.DataFrame]:
        """集中获取所有数据源。"""
        print("\n>>> 正在初始化数据获取和缓存检查...")

        # 1. 基础行情和研报数据
        data = {
            'spot_data_all': self._safe_ak_fetch(ak.stock_zh_a_spot, "A股实时行情"),
            'main_report_raw': self._safe_ak_fetch(ak.stock_profit_forecast_em, "主力研报盈利预测"),
            'financial_abstract_raw': self._safe_ak_fetch(ak.stock_financial_abstract, "财务摘要数据"),
            'market_fund_flow_raw': self._safe_ak_fetch(ak.stock_fund_flow_individual, "5日市场资金流向",
                                                        symbol="5日排行"),
            'market_fund_flow_raw_10': self._safe_ak_fetch(ak.stock_fund_flow_individual, "10日市场资金流向",
                                                           symbol="10日排行"),
            'market_fund_flow_raw_20': self._safe_ak_fetch(ak.stock_fund_flow_individual, "20日市场资金流向",
                                                           symbol="20日排行"),
            'strong_stocks_raw': self._safe_ak_fetch(ak.stock_zt_pool_strong_em, "强势股池",
                                                     date=datetime.now().strftime('%Y%m%d')),
            'consecutive_rise_raw': self._safe_ak_fetch(ak.stock_rank_lxsz_ths, "连续上涨"),
            'ljqs_raw': self._safe_ak_fetch(ak.stock_rank_ljqs_ths, "量价齐升"),
            'cxfl_raw': self._safe_ak_fetch(ak.stock_rank_cxfl_ths, "持续放量"),
        }

        # 2. 均线突破数据
        data['xstp_10_raw'] = self._safe_ak_fetch(ak.stock_rank_xstp_ths, "向上突破10日均线", symbol="10日均线")
        data['xstp_30_raw'] = self._safe_ak_fetch(ak.stock_rank_xstp_ths, "向上突破30日均线", symbol="30日均线")
        data['xstp_60_raw'] = self._safe_ak_fetch(ak.stock_rank_xstp_ths, "向上突破60日均线", symbol="30日均线")

        # 3. 行业板块数据
        print("\n>>> 正在获取行业板块成分股...")
        industry_board_df = self._safe_ak_fetch(ak.stock_board_industry_name_em, '行业板块名称')
        data['top_industry_cons_df'] = self._get_top_industry_constituents(industry_board_df)
        data['industry_board_df'] = industry_board_df

        return data

    def _safe_fetch_constituents(self, symbol: str) -> pd.DataFrame or None:
        """带重试机制获取单个行业板块的成分股。"""
        df = pd.DataFrame()
        for i in range(self.config.DATA_FETCH_RETRIES):
            try:
                df = ak.stock_board_industry_cons_em(symbol=symbol)
                if df is not None and not df.empty:
                    return df
                else:
                    time.sleep(self.config.DATA_FETCH_DELAY)
            except Exception:
                time.sleep(self.config.DATA_FETCH_DELAY)
        return pd.DataFrame()

    def _get_top_industry_constituents(self, industry_board_df: pd.DataFrame) -> pd.DataFrame:
        """获取涨幅前10板块的成分股。"""
        if industry_board_df.empty or '板块名称' not in industry_board_df.columns:
            return pd.DataFrame()

        cache_name = "TopIndustryConstituents_经清洗"
        cleaned_file_path = self._get_file_path(cache_name, cleaned=True)
        cached_df = self._load_data_from_cache(cleaned_file_path)
        if not cached_df.empty:
            return cached_df

        top_industries = industry_board_df.sort_values(by='涨跌幅', ascending=False).head(10)
        all_constituents = []

        # 使用 ThreadPoolExecutor 并行获取成分股
        future_to_industry = {
            self.executor.submit(
                self._safe_fetch_constituents,
                symbol=row['板块名称']
            ): row['板块名称']
            for _, row in top_industries.iterrows()
        }

        for future in as_completed(future_to_industry):
            industry_name = future_to_industry[future]
            try:
                constituents_df = future.result()
                if constituents_df is not None and not constituents_df.empty:
                    if '代码' in constituents_df.columns:
                        constituents_df.rename(columns={'代码': '股票代码'}, inplace=True)

                    if '股票代码' in constituents_df.columns:
                        constituents_df['股票代码'] = constituents_df['股票代码'].astype(str).zfill(6)
                        constituents_df['所属板块'] = industry_name

                    cleaned_constituents = constituents_df[['股票代码', '所属板块']].drop_duplicates()
                    all_constituents.append(cleaned_constituents)
                else:
                    print(
                        f"[WARN] 警告：获取 {industry_name} 的成分股失败或数据为空。")

            except Exception as e:
                print(f"[ERROR] 错误：获取 {industry_name} 的成分股时发生未知错误: {e}")

        if all_constituents:
            final_df = pd.concat(all_constituents, ignore_index=True).drop_duplicates(subset=['股票代码'])
            self._save_data_to_cache(final_df, cleaned_file_path)
            return final_df
        return pd.DataFrame()

    def _fetch_single_code_hist(self, code: str, start_date_str: str, end_date_str: str) -> pd.DataFrame or None:
        """获取单个股票的历史数据，并标准化列名。"""
        try:
            hist_df = ak.stock_zh_a_hist_tx(
                symbol=format_stock_code(code),
                start_date=start_date_str,
                end_date=end_date_str,
                adjust="hfq"  # 前复权
            )
            if hist_df is not None and not hist_df.empty:
                hist_df.rename(columns={
                    'date': 'date', '日期': 'date',
                    'open': 'open', '开盘': 'open',
                    'close': 'close', '收盘': 'close',
                    'high': 'high', '最高': 'high',
                    'low': 'low', '最低': 'low',
                    'volume': 'volume', '成交量': 'volume', 'amount': 'volume',
                }, inplace=True, errors='ignore')

                hist_df['股票代码'] = code

                if 'date' in hist_df.columns:
                    hist_df['date'] = pd.to_datetime(hist_df['date']).dt.strftime('%Y-%m-%d')

                cols_to_keep = ['date', 'open', 'close', 'high', 'low', 'volume', '股票代码']
                return hist_df[[col for col in cols_to_keep if col in hist_df.columns]]

        except Exception:
            pass
        return None

    def _fetch_batch_data_and_report(self, codes_batch: List[str], batch_index: int, total_batches: int,
                                     start_date_str: str, end_date_str: str) -> List[pd.DataFrame]:
        """
        处理一个股票代码批次，并使用 tqdm 显示一个独立的进度条。
        """
        batch_results = []
        tqdm_bar = tqdm(
            codes_batch,
            desc=f"Worker {batch_index + 1}/{total_batches} (Codes: {len(codes_batch)})",
            position=batch_index,
            leave=False
        )

        for code in tqdm_bar:
            df = self._fetch_single_code_hist(code, start_date_str, end_date_str)
            if df is not None and not df.empty:
                batch_results.append(df)

        return batch_results

    def _fetch_hist_data_parallel(self, codes: List[str], days: int) -> pd.DataFrame:
        """
        并行获取指定股票的历史数据，并使用多进度条汇报进度。
        """
        print(
            f"\n正在为 {len(codes)} 只股票下载 {days} 天的历史数据 (使用 {self.config.MAX_WORKERS} 个并发工作进程/进度条)...")

        end_date = datetime.now()
        start_date = end_date - timedelta(days=days)
        start_date_str = start_date.strftime("%Y%m%d")
        end_date_str = end_date.strftime("%Y%m%d")

        # 缓存文件名和加载缓存逻辑
        cache_name = f"MACD_hist_data_cache_{len(codes)}"
        file_path = self._get_file_path(cache_name, cleaned=True)
        cached_df = self._load_data_from_cache(file_path)

        if not cached_df.empty:
            if 'date' in cached_df.columns and 'close' in cached_df.columns:
                cached_df['date'] = pd.to_datetime(cached_df['date']).dt.strftime('%Y-%m-%d')
                return cached_df
            else:
                print("[WARN] 历史数据缓存文件缺少关键英文列，将重新获取。")

        max_workers = self.config.MAX_WORKERS
        total_codes = len(codes)
        batch_size = math.ceil(total_codes / max_workers)
        codes_batches = [codes[i:i + batch_size] for i in range(0, total_codes, batch_size)]

        all_data_lists = []
        future_to_batch = {}
        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            for i, batch in enumerate(codes_batches):
                if not batch: continue
                future = executor.submit(
                    self._fetch_batch_data_and_report,
                    codes_batch=batch,
                    batch_index=i,
                    total_batches=len(codes_batches),
                    start_date_str=start_date_str,
                    end_date_str=end_date_str
                )
                future_to_batch[future] = i

            for future in as_completed(future_to_batch):
                try:
                    batch_results = future.result()
                    all_data_lists.append(batch_results)
                except Exception as e:
                    batch_index = future_to_batch.get(future, 'N/A')
                    print(f"[ERROR] 批次 {batch_index+1} 处理出错: {e}")

        # 清理 tqdm 进度条
        tqdm.clear()

        all_data = [df for df_list in all_data_lists for df in df_list if df_list]

        if all_data:
            merged_df = pd.concat(all_data, ignore_index=True)
            self._save_data_to_cache(merged_df, file_path)
            return merged_df
        return pd.DataFrame()

    # ==========================================================================
    # MACD 计算方法 (增加零轴过滤金叉信号)
    # ==========================================================================
    def _custom_macd(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        [自定义实现] 同时计算 MACD 标准周期 (12, 26, 9) 和加速周期 (6, 13, 5) 的
        DIF, DEA，并生成零轴过滤后的金叉信号。
        """
        if 'close' not in df.columns:
            return df

        close = df['close']

        macd_periods = {
            '12269': (12, 26, 9),  # 标准中长线周期
            '6135': (6, 13, 5)     # 短线/加速周期
        }

        for name, (fast, slow, signal) in macd_periods.items():
            dif_col = f'DIF_{name}'
            dea_col = f'DEA_{name}'
            azl_gc_col = f'MACD_{name}_零轴上金叉'
            bzl_gc_col = f'MACD_{name}_零轴下金叉'

            ema_fast_col = f'EMA_{fast}_{name}'
            ema_slow_col = f'EMA_{slow}_{name}'

            df[ema_fast_col] = close.ewm(span=fast, adjust=False).mean()
            df[ema_slow_col] = close.ewm(span=slow, adjust=False).mean()

            df[dif_col] = df[ema_fast_col] - df[ema_slow_col]
            df[dea_col] = df[dif_col].ewm(span=signal, adjust=False).mean()

            # 基础金叉信号
            gc_base = (df[dif_col] > df[dea_col]) & \
                      (df[dif_col].shift(1).fillna(-np.inf) <= df[dea_col].shift(1).fillna(-np.inf))

            # 零轴过滤
            is_above_zero = (df[dea_col] >= 0)
            is_below_zero = (df[dea_col] < 0)

            # 零轴上金叉: 金叉 AND DEA >= 0
            df[azl_gc_col] = np.where(gc_base & is_above_zero, 1, 0)

            # 零轴下金叉: 金叉 AND DEA < 0
            df[bzl_gc_col] = np.where(gc_base & is_below_zero, 1, 0)

            # 清理中间计算列
            cols_to_drop = [ema_fast_col, ema_slow_col, dif_col, dea_col]
            df.drop(columns=[col for col in cols_to_drop if col in df.columns],
                    inplace=True, errors='ignore')

        return df

    # ==========================================================================
    # CCI 专业化分类函数
    # ==========================================================================
    def _classify_cci_level(self, cci_value: float) -> str:
        """根据CCI值，将其分类为专业的市场状态术语。"""
        if pd.isna(cci_value):
            return 'N/A'

        if cci_value > 200:
            return f'极度超买 ({cci_value:.2f})'
        elif cci_value >= 100:
            return f'强势超买 ({cci_value:.2f})'
        elif cci_value > -100:
            return '' # 常态波动不记录信号
        elif cci_value >= -200:
            return f'弱势超卖 ({cci_value:.2f})'
        else:
            return f'极度超卖 ({cci_value:.2f})'

    # ==========================================================================

    def _process_ta_signals(self, all_codes: List[str], hist_df_all: pd.DataFrame, spot_df: pd.DataFrame) -> Dict[
        str, pd.DataFrame]:
        """计算并提取所有技术指标信号。"""
        print(f"\n正在对 {len(all_codes)} 只股票进行技术分析...")

        ta_signals = {
            'MACD_12269_零轴上金叉': [], 'MACD_12269_零轴下金叉': [],
            'MACD_6135_零轴上金叉': [], 'MACD_6135_零轴下金叉': [],
            'KDJ': [], 'CCI': [], 'RSI': [], 'BOLL': []
        }

        if hist_df_all.empty:
            print("[WARN] 历史数据为空，跳过技术分析。")
            return {key: pd.DataFrame(columns=['股票代码', f'{key}_Signal']) for key in ta_signals.keys()}

        hist_df_all.sort_values(['股票代码', 'date'], inplace=True)

        for code in all_codes:
            df = hist_df_all[hist_df_all['股票代码'] == code].copy()

            if df.empty or len(df) < 30:
                continue

            for col in ['close', 'open', 'high', 'low']:
                if col in df.columns:
                    df[col] = pd.to_numeric(df[col], errors='coerce')

            df.dropna(subset=['close'], inplace=True)
            if df.empty: continue

            if 'close' not in df.columns or 'open' not in df.columns or 'high' not in df.columns or 'low' not in df.columns:
                continue

            try:
                # 1. MACD (零轴过滤金叉)
                df = self._custom_macd(df)

                for name in ['12269', '6135']:
                    azl_col = f'MACD_{name}_零轴上金叉'
                    bzl_col = f'MACD_{name}_零轴下金叉'

                    if azl_col in df.columns and df[azl_col].iloc[-1] == 1:
                        ta_signals[azl_col].append({'股票代码': code, 'MACD_Signal': '零轴上金叉'})

                    if bzl_col in df.columns and df[bzl_col].iloc[-1] == 1:
                        ta_signals[bzl_col].append({'股票代码': code, 'MACD_Signal': '零轴下金叉'})

                # 2. KDJ (超卖区金叉)
                df.ta.stoch(append=True, close='close', high='high', low='low')
                kdj_cols = [col for col in df.columns if col.startswith('STOCHk_') or col.startswith('STOCHd_')]
                if len(kdj_cols) >= 2:
                    k_col = kdj_cols[0]
                    d_col = kdj_cols[1]
                    df['KDJ_OVS'] = np.where((df[k_col] < 20) & (df[d_col] < 20), 1, 0)
                    df['KDJ_CROSS'] = np.where(
                        (df[k_col] > df[d_col]) & (df[k_col].shift(1) <= df[d_col].shift(1)), 1, 0)

                    if df['KDJ_OVS'].iloc[-5:-1].sum() > 0 and df['KDJ_CROSS'].iloc[-1] == 1:
                        ta_signals['KDJ'].append({'股票代码': code, 'KDJ_Signal': '超卖区金叉'})

                # 3. CCI (专业分类)
                df.ta.cci(append=True, close='close', high='high', low='low')
                cci_cols = [col for col in df.columns if col.startswith('CCI_')]
                if cci_cols:
                    cci_col = cci_cols[0]
                    current_cci = df[cci_col].iloc[-1]
                    cci_signal = self._classify_cci_level(current_cci)
                    if cci_signal:
                        ta_signals['CCI'].append(
                            {'股票代码': code, 'CCI_Signal': cci_signal})

                # 4. RSI (超卖低位)
                df.ta.rsi(append=True, close='close')
                rsi_cols = [col for col in df.columns if col.startswith('RSI_')]
                if rsi_cols:
                    rsi_col = rsi_cols[0]
                    if df[rsi_col].iloc[-1] < 30:
                        ta_signals['RSI'].append(
                            {'股票代码': code, 'RSI_Signal': f"超卖低位 ({df[rsi_col].iloc[-1]:.2f})"})

                # 5. BOLL (低波/缩口)
                df.ta.bbands(append=True, length=20, std=2, close='close')
                boll_cols = [col for col in df.columns if col.startswith('BBL_')]
                if boll_cols:
                    lower_band = boll_cols[0]
                    upper_band = [col for col in df.columns if col.startswith('BBU_')][0]
                    df['BOLL_BANDWIDTH'] = (df[upper_band] - df[lower_band]) / df['close']
                    if df['BOLL_BANDWIDTH'].iloc[-5:].mean() < df['BOLL_BANDWIDTH'].mean():
                        ta_signals['BOLL'].append({'股票代码': code, 'BOLL_Signal': '低波/缩口'})

            except KeyError as ke:
                print(f"[ERROR] 计算 {code} 的 TA 指标时出错: 关键指标列名丢失 ({ke})")
            except Exception as e:
                print(f"[ERROR] 计算 {code} 的 TA 指标时出错: {e}")
                continue

        final_ta_dfs = {}
        for key, value in ta_signals.items():
            final_ta_dfs[key] = pd.DataFrame(value)

        return final_ta_dfs

    def _process_xstp_and_filter(self, raw_data: Dict[str, pd.DataFrame], spot_df: pd.DataFrame) -> pd.DataFrame:
        """处理并合并均线突破数据，并进行多头排列筛选。"""
        print("正在处理并合并均线突破数据...")

        processed_df10 = raw_data['xstp_10_raw'].rename(columns={'最新价': '10日均线最新价'})
        processed_df30 = raw_data['xstp_30_raw'].rename(columns={'最新价': '30日均线最新价'})
        processed_df60 = raw_data['xstp_60_raw'].rename(columns={'最新价': '60日均线最新价'})

        merged_df = pd.concat([
            processed_df10[['股票代码', '股票简称']].dropna(subset=['股票代码']),
            processed_df30[['股票代码', '股票简称']].dropna(subset=['股票代码']),
            processed_df60[['股票代码', '股票简称']].dropna(subset=['股票代码'])
        ]).drop_duplicates(subset=['股票代码'])

        xstp_base = merged_df[['股票代码', '股票简称']].drop_duplicates()
        xstp_base = pd.merge(xstp_base, processed_df10[['股票代码', '10日均线最新价']], on='股票代码', how='left')
        xstp_base = pd.merge(xstp_base, processed_df30[['股票代码', '30日均线最新价']], on='股票代码', how='left')
        xstp_base = pd.merge(xstp_base, processed_df60[['股票代码', '60日均线最新价']], on='股票代码', how='left')

        xstp_base = pd.merge(xstp_base, spot_df[['股票代码', '最新价']], on='股票代码', how='left')

        cols_to_convert = [col for col in xstp_base.columns if '最新价' in col or col == '最新价']
        for col in cols_to_convert:
            xstp_base[col] = pd.to_numeric(xstp_base[col], errors='coerce')

        filtered_df = xstp_base[
            (xstp_base['最新价'] > xstp_base['10日均线最新价']) &
            (
                (xstp_base['10日均线最新价'] > xstp_base['30日均线最新价'].fillna(float('-inf'))) |
                (xstp_base['30日均线最新价'] > xstp_base['60日均线最新价'].fillna(float('-inf')))
            )
        ].copy()

        filtered_df['完全多头排列'] = filtered_df.apply(
            lambda row: '是' if row['10日均线最新价'] > row['30日均线最新价'] and row['30日均线最新价'] > row[
                '60日均线最新价'] else '否',
            axis=1
        )

        filtered_df.rename(columns={'最新价': '当前价格'}, inplace=True)
        return filtered_df.fillna('N/A')

    # <--- 修复后的 _consolidate_data 方法 --->
    def _consolidate_data(self, processed_data: Dict[str, pd.DataFrame]) -> pd.DataFrame:
        """
        合并所有数据源和信号，生成最终汇总报告。
        **修复点：确保 '最新价' 和 '资金流入' 系列数据正确合并。**
        """
        print("\n>>> 正在汇总所有数据和信号 (技术指标作为独立列)...")

        # 1. 提取所有有信号的股票代码作为基础
        all_codes = set()
        data_sources = [
            processed_data.get('processed_main_report'),
            processed_data.get('processed_xstp_df'),
            processed_data.get('market_fund_flow_raw'),
            processed_data.get('market_fund_flow_raw_10'),
            processed_data.get('market_fund_flow_raw_20'),
            processed_data.get('strong_stocks_raw'),
            processed_data.get('consecutive_rise_raw'),
            processed_data.get('ljqs_raw'),
            processed_data.get('cxfl_raw'),
            processed_data.get('MACD_12269_零轴上金叉', pd.DataFrame()),
            processed_data.get('MACD_12269_零轴下金叉', pd.DataFrame()),
            processed_data.get('MACD_6135_零轴上金叉', pd.DataFrame()),
            processed_data.get('MACD_6135_零轴下金叉', pd.DataFrame()),
            processed_data.get('KDJ', pd.DataFrame()),
            processed_data.get('CCI', pd.DataFrame()),
            processed_data.get('RSI', pd.DataFrame()),
            processed_data.get('BOLL', pd.DataFrame()),
        ]
        for df in data_sources:
            if '股票代码' in df.columns and not df.empty:
                all_codes.update(df['股票代码'].unique())

        if not all_codes:
            return pd.DataFrame()

        final_df = pd.DataFrame(list(all_codes), columns=['股票代码'])
        final_df['股票代码'] = final_df['股票代码'].astype(str)

        # 2. 鲁棒地合并基础信息 (简称, 价格)
        spot_df = processed_data.get('spot_data_all', pd.DataFrame())
        report_df_base = processed_data.get('processed_main_report', pd.DataFrame())

        if '股票代码' in spot_df.columns:
            spot_df['股票代码'] = spot_df['股票代码'].astype(str)

        # 2a. 合并名称
        name_source_spot = spot_df[['股票代码', '股票简称']].drop_duplicates(
            subset=['股票代码']) if '股票简称' in spot_df.columns else pd.DataFrame(columns=['股票代码', '股票简称'])
        name_source_report = report_df_base[['股票代码', '股票简称']].drop_duplicates(
            subset=['股票代码']) if '股票简称' in report_df_base.columns else pd.DataFrame(columns=['股票代码', '股票简称'])

        name_source = pd.concat([name_source_spot, name_source_report]).drop_duplicates(
            subset=['股票代码'], keep='first')

        final_df = pd.merge(final_df, name_source, on='股票代码', how='left')

        # 2b. 合并最新价格
        price_source = spot_df[['股票代码', '最新价']].drop_duplicates(subset=['股票代码'])
        final_df = pd.merge(final_df, price_source, on='股票代码', how='left')
        
        final_df['股票简称'] = final_df['股票简称'].fillna('N/A')
        final_df['最新价'] = final_df['最新价'].fillna('N/A')

        # 3. 合并信号和细节
        # A. 主力研报信号 (使用买入次数)
        report_df = processed_data['processed_main_report'][['股票代码', '研报买入次数']]
        final_df = pd.merge(final_df, report_df, on='股票代码', how='left')
        final_df['研报买入次数'] = pd.to_numeric(final_df['研报买入次数'], errors='coerce').fillna(0).astype(int)

        # B. 均线信号 (多头排列)
        xstp_df = processed_data['processed_xstp_df']
        xstp_cols = ['股票代码', '完全多头排列', '当前价格', '10日均线最新价', '30日均线最新价', '60日均线最新价']
        if not xstp_df.empty and '股票代码' in xstp_df.columns:
            cols_present = [col for col in xstp_cols if col in xstp_df.columns]
            merge_df = xstp_df[cols_present].drop_duplicates(subset=['股票代码'])
            final_df = pd.merge(final_df, merge_df, on='股票代码', how='left')
        if '完全多头排列' not in final_df.columns:
            final_df['完全多头排列'] = '否'
        else:
            final_df['完全多头排列'] = final_df['完全多头排列'].fillna('否')

        # C. 资金流向-5d, 10d, 20d (核心修复部分)
        if '股票简称' not in final_df.columns:
             final_df['股票简称'] = final_df['股票代码'] # 无法关联时，使用代码做占位符

        # 5日资金流向
        fund_flow_df_5 = processed_data.get('market_fund_flow_raw', pd.DataFrame())
        if not fund_flow_df_5.empty and '股票简称' in fund_flow_df_5.columns and '资金流入净额' in fund_flow_df_5.columns:
            merge_df_5 = fund_flow_df_5[['股票简称', '资金流入净额']].rename(columns={'资金流入净额': '5日资金流入'}).drop_duplicates(subset=['股票简称'])
            final_df = pd.merge(final_df, merge_df_5, on='股票简称', how='left')
        else:
            final_df['5日资金流入'] = 'N/A'

        # 10日资金流向
        fund_flow_df_10 = processed_data.get('market_fund_flow_raw_10', pd.DataFrame())
        if not fund_flow_df_10.empty and '股票简称' in fund_flow_df_10.columns and '资金流入净额' in fund_flow_df_10.columns:
            merge_df_10 = fund_flow_df_10[['股票简称', '资金流入净额']].rename(columns={'资金流入净额': '10日资金流入'}).drop_duplicates(subset=['股票简称'])
            final_df = pd.merge(final_df, merge_df_10, on='股票简称', how='left')
        else:
             final_df['10日资金流入'] = 'N/A'

        # 20日资金流向
        fund_flow_df_20 = processed_data.get('market_fund_flow_raw_20', pd.DataFrame())
        if not fund_flow_df_20.empty and '股票简称' in fund_flow_df_20.columns and '资金流入净额' in fund_flow_df_20.columns:
            merge_df_20 = fund_flow_df_20[['股票简称', '资金流入净额']].rename(columns={'资金流入净额': '20日资金流入'}).drop_duplicates(subset=['股票简称'])
            final_df = pd.merge(final_df, merge_df_20, on='股票简称', how='left')
        else:
            final_df['20日资金流入'] = 'N/A'

        # 统一处理资金流入列的类型
        for col in ['5日资金流入', '10日资金流入', '20日资金流入']:
            if col in final_df.columns:
                final_df[col] = pd.to_numeric(final_df[col], errors='coerce').fillna('N/A')
            elif col not in final_df.columns:
                final_df[col] = 'N/A'
        
        # D. 强势股
        strong_df = processed_data.get('strong_stocks_raw', pd.DataFrame())
        final_df['强势股'] = np.where(final_df['股票代码'].isin(strong_df['股票代码']), '是', '否')

        # E. 连续上涨
        rise_df = processed_data.get('consecutive_rise_raw', pd.DataFrame())
        if '连涨天数' in rise_df.columns and not rise_df.empty:
            rise_df['股票代码'] = rise_df['股票代码'].astype(str)
            final_df = pd.merge(final_df, rise_df[['股票代码', '连涨天数']].drop_duplicates(subset=['股票代码']), on='股票代码', how='left')
            final_df['连涨天数'] = pd.to_numeric(final_df['连涨天数'], errors='coerce').fillna(0)
        else:
            final_df['连涨天数'] = 0

        # F. 量价齐升
        ljqs_df = processed_data.get('ljqs_raw', pd.DataFrame())
        final_df['量价齐升'] = np.where(final_df['股票代码'].isin(ljqs_df['股票代码']), '是', '否')

        # G. 持续放量
        cxfl_df = processed_data.get('cxfl_raw', pd.DataFrame())
        if '放量天数' in cxfl_df.columns and not cxfl_df.empty:
            cxfl_df['股票代码'] = cxfl_df['股票代码'].astype(str)
            final_df = pd.merge(final_df, cxfl_df[['股票代码', '放量天数']].drop_duplicates(subset=['股票代码']), on='股票代码', how='left')
        else:
            final_df['放量天数'] = 0
        final_df['放量天数'] = final_df['放量天数'].fillna(0)
        final_df['放量天数'] = final_df['放量天数'].astype(int)

        # H. TA 信号细节：MACD 合并
        macd_periods = ['12269', '6135']
        
        for name in macd_periods:
            final_col_name = f'MACD_{name}'
            
            key_azl = f'MACD_{name}_零轴上金叉'
            df_azl = processed_data.get(key_azl, pd.DataFrame())
            df_azl_merged = pd.DataFrame(columns=['股票代码', final_col_name])
            if not df_azl.empty:
                df_azl_merged = df_azl[['股票代码', 'MACD_Signal']].copy()
                df_azl_merged.rename(columns={'MACD_Signal': final_col_name}, inplace=True)

            key_bzl = f'MACD_{name}_零轴下金叉'
            df_bzl = processed_data.get(key_bzl, pd.DataFrame())
            df_bzl_merged = pd.DataFrame(columns=['股票代码', final_col_name])
            if not df_bzl.empty:
                df_bzl_merged = df_bzl[['股票代码', 'MACD_Signal']].copy()
                df_bzl_merged.rename(columns={'MACD_Signal': final_col_name}, inplace=True)

            merged_macd_df = pd.concat([df_azl_merged, df_bzl_merged]).drop_duplicates(subset=['股票代码'], keep='first')
            
            final_df = pd.merge(final_df, merged_macd_df, on='股票代码', how='left')
            final_df[final_col_name] = final_df[final_col_name].fillna('')

        # 非 MACD 的 TA 信号合并
        ta_dfs_to_merge = []
        
        kdj_df = processed_data.get('KDJ', pd.DataFrame())
        if not kdj_df.empty:
            ta_dfs_to_merge.append(kdj_df[['股票代码', 'KDJ_Signal']].rename(
                columns={'KDJ_Signal': 'KDJ_Signal'}))
        cci_df = processed_data.get('CCI', pd.DataFrame())
        if not cci_df.empty:
            ta_dfs_to_merge.append(cci_df[['股票代码', 'CCI_Signal']].rename(
                columns={'CCI_Signal': 'CCI_Signal'}))
        rsi_df = processed_data.get('RSI', pd.DataFrame())
        if not rsi_df.empty:
            rsi_df['RSI_Signal'] = rsi_df['RSI_Signal'].astype(str).str.split(' ').str[0]
            ta_dfs_to_merge.append(rsi_df[['股票代码', 'RSI_Signal']].rename(
                columns={'RSI_Signal': 'RSI_Signal'}))
        boll_df = processed_data.get('BOLL', pd.DataFrame())
        if not boll_df.empty:
            ta_dfs_to_merge.append(boll_df[['股票代码', 'BOLL_Signal']].rename(
                columns={'BOLL_Signal': 'BOLL_Signal'}))

        for ta_df in ta_dfs_to_merge:
            final_df = pd.merge(final_df, ta_df.drop_duplicates(subset=['股票代码']), on='股票代码', how='left')

        for col in ['KDJ_Signal', 'CCI_Signal', 'RSI_Signal', 'BOLL_Signal']:
            if col in final_df.columns:
                final_df[col] = final_df[col].fillna('')
            else:
                final_df[col] = ''

        # 4. 过滤掉没有任何主要信号的股票
        def has_any_signal(row):
            return (row['研报买入次数'] > 0 or row['完全多头排列'] == '是' or row['强势股'] == '是' or row['量价齐升'] == '是'
                    or row['MACD_12269'] != '' or row['MACD_6135'] != ''
                    or row['KDJ_Signal'] != '' or row['CCI_Signal'] != '' or row['RSI_Signal'] != ''
                    or row['BOLL_Signal'] != '' )

        final_df = final_df[final_df.apply(has_any_signal, axis=1)].copy()

        # 5. 整理输出并排序
        final_df.sort_values(by=['研报买入次数', '连涨天数', '放量天数'], ascending=[False, False, False], inplace=True)
        final_df.reset_index(drop=True, inplace=True)
        final_df.insert(0, '序号', range(1, len(final_df) + 1))
        final_df['完整股票代码'] = final_df['股票代码'].apply(format_stock_code)


        return final_df
    # <--- 修复后的 _consolidate_data 方法结束 --->

    def _generate_excel_report(self, sheets_data: Dict[str, pd.DataFrame]):
        """
        生成 Excel 报告，将所有数据表保存到不同的工作表。
        """
        if not sheets_data:
            print("[WARN] 没有数据可生成报告。")
            return

        report_file_name = f"A股分析报告_{self.today_str}.xlsx"
        report_path = os.path.join(self.config.SAVE_DIRECTORY, report_file_name)

        try:
            writer = pd.ExcelWriter(report_path, engine='xlsxwriter')
            workbook = writer.book

            # 定义格式
            header_format = workbook.add_format({
                'bold': True, 'text_wrap': True, 'valign': 'vcenter',
                'fg_color': '#D7E4BC', 'border': 1
            })
            currency_format = workbook.add_format({'num_format': '#,##0.00'}) # 货币格式
            code_format = workbook.add_format({'num_format': '@'}) # 文本格式

            for sheet_name, df in sheets_data.items():
                if df is None or df.empty:
                    print(f" - 警告：工作表 '{sheet_name}' 数据为空，跳过创建。")
                    continue

                df.to_excel(writer, sheet_name=sheet_name, startrow=1, header=False, index=False)
                worksheet = writer.sheets[sheet_name]

                # 写入表头
                for col_num, value in enumerate(df.columns.values):
                    worksheet.write(0, col_num, value, header_format)

                # 设置列宽和格式
                for i, col in enumerate(df.columns):
                    max_len = max(df[col].astype(str).str.len().max(), len(col))
                    col_width = min(max_len + 2, 30)
                    if col == '最新价' or '资金流入' in col or '价格' in col or '价' in col or '线' in col or '均线' in col:
                        worksheet.set_column(i, i, col_width, currency_format)
                    elif '代码' in col:
                        worksheet.set_column(i, i, 10, code_format)
                    else:
                        worksheet.set_column(i, i, col_width)

            writer.close()
            print(f" - 报告已成功生成并保存到: {report_path}")

        except Exception as e:
            print(f"[FATAL] 致命错误：生成 Excel 报告失败。原因: {e}")
            raise

    def run(self):
        """主运行方法。"""
        print(f"股票分析程序启动 (Today: {self.today_str})")

        # 清理旧的临时文件
        for filename in os.listdir(self.temp_dir):
            if not filename.endswith(f"{self.today_str}.txt"):
                try:
                    os.remove(os.path.join(self.temp_dir, filename))
                except Exception:
                    pass
        print("旧的临时数据文件清理完成。")

        try:
            # 1. 获取所有原始数据
            raw_data = self._get_all_raw_data()

            processed_main_report = raw_data.get('main_report_raw', pd.DataFrame())
            spot_df = raw_data.get('spot_data_all', pd.DataFrame())

            # --- 对主力研报数据进行条件过滤 (买入评级 >= 1) ---
            report_col = '机构投资评级(近六个月)-买入'
            if not processed_main_report.empty and report_col in processed_main_report.columns:
                processed_main_report[report_col] = pd.to_numeric(processed_main_report[report_col], errors='coerce').fillna(0)
                processed_main_report = processed_main_report[processed_main_report[report_col] >= 1].copy()
                processed_main_report.rename(columns={report_col: '研报买入次数'}, inplace=True)
            raw_data['processed_main_report'] = processed_main_report

            # 2. 获取并处理历史数据，以便进行技术分析 (仅下载研报过滤后的股票)
            all_codes_for_hist = list(processed_main_report['股票代码'].unique())

            if not all_codes_for_hist:
                 print("[WARN] 主力研报过滤后股票列表为空，跳过历史K线下载。")
                 hist_df_all = pd.DataFrame()
            else:
                 hist_df_all = self._fetch_hist_data_parallel(all_codes_for_hist, days=150)

            # 3. 计算技术指标信号
            ta_signals = self._process_ta_signals(all_codes_for_hist, hist_df_all, spot_df)

            # 4. 处理均线突破数据
            processed_xstp_df = self._process_xstp_and_filter(raw_data, spot_df)
            raw_data['processed_xstp_df'] = processed_xstp_df

            # 5. 合并所有数据源和信号
            processed_data = raw_data.copy()
            processed_data.update(ta_signals)

            final_report_df = self._consolidate_data(processed_data)

            # 6. 生成报告
            sheets_data = {
                '汇总报告 (推荐)': final_report_df,
                '主力研报筛选': processed_data['processed_main_report'],
                '均线多头排列': processed_xstp_df,
                '实时行情': spot_df,
                '5日市场资金流向': raw_data['market_fund_flow_raw'],
                '10日市场资金流向': raw_data['market_fund_flow_raw_10'],
                '20日市场资金流向': raw_data['market_fund_flow_raw_20'],
                '强势股池': raw_data['strong_stocks_raw'],
                '连续上涨': raw_data['consecutive_rise_raw'],
                '量价齐升': raw_data['ljqs_raw'],
                '持续放量': raw_data['cxfl_raw'],
                'MACD_12269_零轴上金叉': ta_signals.get('MACD_12269_零轴上金叉', pd.DataFrame()),
                'MACD_12269_零轴下金叉': ta_signals.get('MACD_12269_零轴下金叉', pd.DataFrame()),
                'MACD_6135_零轴上金叉': ta_signals.get('MACD_6135_零轴上金叉', pd.DataFrame()),
                'MACD_6135_零轴下金叉': ta_signals.get('MACD_6135_零轴下金叉', pd.DataFrame()),
                'KDJ超卖金叉': ta_signals.get('KDJ', pd.DataFrame()),
                'CCI专业状态': ta_signals.get('CCI', pd.DataFrame()),
                'RSI超卖': ta_signals.get('RSI', pd.DataFrame()),
                'BOLL低波': ta_signals.get('BOLL', pd.DataFrame()),
                '前十板块成分股': raw_data['top_industry_cons_df'],
                '行业板块名称': raw_data['industry_board_df'],
            }
            self._generate_excel_report(sheets_data)

        except Exception as e:
            print(f"\n[FATAL] 程序执行过程中发生致命错误: {e}")
            self.executor.shutdown(wait=False)
            raise


if __name__ == '__main__':
    try:
        analyzer = StockAnalyzer()
        analyzer.run()
    except Exception as e:
        print(f"\n[CRITICAL] 最终错误: {e}")
